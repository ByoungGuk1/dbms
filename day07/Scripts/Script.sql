SELECT DISTINCT tbp.PRODUCT_NAME
FROM TBL_ORDER tbo
JOIN TBL_PRODUCT tbp
ON tbo.PRODUCT_ID = tbp.ID;


CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE TBL_SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQLD_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(255),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모니터', 30000);


CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE TBL_SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(255),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES TBL_SQLD_PRODUCT(ID)
);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 1);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '직접 수령', 2);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2);


CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
   ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
   PRODUCT_NAME VARCHAR2(255),
   PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 10000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 30000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 35000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 300000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 220000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 40000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 30000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 55000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 12000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 30000);

SELECT * FROM TBL_PRODUCT;

-- 논리 연산자 --
-- 1. BETWEEN A AND B : A부터 B까지

SELECT *
FROM (
	SELECT tbo.*, tbp.PRODUCT_BRAND, tbp.PRODUCT_NAME, tbp.PRODUCT_PRICE, tbp.PRODUCT_STOCK
	FROM TBL_ORDER tbo
	JOIN TBL_PRODUCT tbp
	ON tbo.PRODUCT_ID = tbp.ID
)
WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;

--  2. ?= , <> : 같지않다

SELECT *
FROM (
	SELECT tbo.*, tbp.PRODUCT_BRAND, tbp.PRODUCT_NAME, tbp.PRODUCT_PRICE, tbp.PRODUCT_STOCK
	FROM TBL_ORDER tbo
	JOIN TBL_PRODUCT tbp
	ON tbo.PRODUCT_ID = tbp.ID
)
WHERE PRODUCT_PRICE <> 119000;

-- 3.
-- *** IS NULL : NULL 인 데이터 조회
-- *** IS NOT NULL : NULL 이 아닌 데이터 조회

SELECT *
FROM (
	SELECT tbo.*, tbp.PRODUCT_BRAND, tbp.PRODUCT_NAME, tbp.PRODUCT_PRICE, tbp.PRODUCT_STOCK
	FROM TBL_ORDER tbo
	JOIN TBL_PRODUCT tbp
	ON tbo.PRODUCT_ID = tbp.ID
)
WHERE ORDER_END_DATE IS NOT NULL;

-- 문자열 함수 --
-- CONCTA(값1, 값2)
SELECT CONCAT('HELLO', 'WORLD') AS "인사" FROM DUAL;
SELECT 'HELLO' || 'WORLD' AS "인사" FROM DUAL;

-- LENGTH() : RLFDL
SELECT LENGTH('HELLO' || 'WORLD') FROM DUAL;

-- SUBSTR(데이터, 시작 자릿수, 가져올 갯수) : 문자열 추출
-- SUBSTRING() - MySQL
SELECT SUBSTR('오늘 점심 뭐 먹지?', 4, 2) FROM DUAL;

-- 중복 연산자 --
--1. DISTINCT	: 조회 결과의 중복을 제거

--2. UNION		: (합집합) 중복을 제거하고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--3. UNION ALL	: (합집합) 중복을 제거하지 않고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION ALL
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--4. MINUS		: 차집합
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
MINUS
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--5. INTERSECT	: 교집합
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
INTERSECT
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

-- 아무것도 안나오는 상태를 공집합. 위 INTERSECT의 결과값이 없으므로 공집합

---

-- NULL 관련 연산자
-- 1. IS NULL : NULL 이면 TRUE
-- 2. IS NOT NULL : NULL 이 아니면 TRUE

---

-- 함수 --
--------
-- 문자열 함수 --
-- UPPER() : 대문자로 변경
SELECT UPPER('hello') FROM DUAL;

-- LOWER() : 소문자로 변경
SELECT LOWER('DATTING') FROM DUAL;

-- TRIM() : 공백제거
SELECT TRIM('                   점 심 맛 있 게 먹 었 어 ?') FROM DUAL;

-- REPLACE(바꿀 문자열, 찾을 문자, 바뀔 문자) : 특정 문자를 치환
SELECT REPLACE('                   점 심 맛 있 게 먹 었 어 ?', ' ', '') FROM DUAL;

-- INSTR() : 특정 문자열의 위치 반환 -> 인덱스가 1부터 시작됌
SELECT INSTR('강사님 질문해도 될까요?', '질문해') FROM DUAL;

-- 날짜 함수 --
-- SYSDATE : 현재 날짜, 시, 분, 초
SELECT SYSDATE FROM DUAL;

-- CURRENT_DATE : 현재 날짜
SELECT CURRENT_DATE FROM DUAL;

-- 현재 날짜를 기준으로 월을 추가
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL; 
SELECT ADD_MONTHS(SYSDATE, -2) FROM DUAL; 

-- MONTHS_BETWEEN(값1, 값2) : 두 날짜간 개월 차
SELECT MONTHS_BETWEEN(SYSDATE, '2024-07-12') FROM DUAL; 

-- 두 날짜간 일수 차
SELECT TO_DATE(SYSDATE) - TO_DATE('2024-07-12') FROM DUAL;

-- 두 날짜간 일자, 시간, 분, 초 차이
SELECT SYSDATE - TO_TIMESTAMP('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

-- 두 날짜간 시 차이
SELECT (SYSDATE - TO_TIMESTAMP('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS')) *24 FROM DUAL;

-- 두 날짜간 분 차이
SELECT (SYSDATE - TO_TIMESTAMP('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS')) *24 *60 FROM DUAL;

-- 두 날짜간 초 차이
SELECT (SYSDATE - TO_TIMESTAMP('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS')) *24 *60 *60 FROM DUAL;

-- NEXT_DAY()
-- 특정 날짜 이후의 지정된 요일을 반환
SELECT NEXT_DAY(SYSDATE, '월') FROM DUAL;
SELECT NEXT_DAY(SYSDATE, '월요일') FROM DUAL;

-- TRUNC() : 날짜의 시각을 제거하고 날짜만 반환
SELECT TRUNC(TO_TIMESTAMP('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS')) FROM DUAL; 

-- TRUNCATE 
--DROP TABLE ----
--SELECT * FROM ----;
--ㄴ> 테이블의 삭제
--TRUNCATE TABLE ----;
--SELECT * FROM ----;
--ㄴ> 테이블의 데이터만 삭제

SELECT
	TO_DATE('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS') AS "기준일",
	TO_CHAR(TO_DATE('2025-09-18 11:15:15', 'YYYY-MM-DD HH24:MI:SS'), 'HH') AS "시간만"
FROM DUAL;

-- ABS() : 절댓값
SELECT ABS(-100) FROM DUAL;

-- CEIL() : 올림
SELECT CEIL(3.141592) FROM DUAL;

-- FLOOR() : 내림
SELECT FLOOR(3.141592) FROM DUAL;

-- MOD() : 나머지 %연산자처럼 생각
SELECT MOD(3, 2) FROM DUAL;

-- ROUND() : 반올림

-- POWER() : 거듭제곱
SELECT POWER(2,8) FROM DUAL;

-- 변환 함수
SELECT TO_NUMBER('12492.5') + 10 FROM DUAL;
SELECT TO_TIMESTAMP('2025-02-25 12:31:15', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;
-- TO_DATE
SELECT CAST(10 AS VARCHAR2(255)) FROM DUAL;
SELECT CAST('2025-02-27' AS DATE) FROM DUAL;

-- **중요** NULL 함수 --
-- NVL(값1, 값2) : 첫 번째 값이 NULL이면 두 번째 값을 반환
SELECT NVL(NULL, '대체 값') FROM DUAL;

-- NVL2(값1, 값2, 값3) : 3항 연산자와 비슷하게 생각, 값1이 NULL이면 값3, NULL이 아니면 값2
SELECT NVL2(NULL, 'TRUE', 'FALSE') FROM DUAL;

-- COALESCE(값1, 값2, 값3, ... ) : 값 중 NULL이 아닌 첫번째 값을 반환
SELECT COALESCE (NULL, 0, 1, 15) FROM DUAL;

-- NULLIF(값1, 값2) : 두 값이 같으면 NULL, 아니라면 첫번째 값
SELECT NULLIF(10, NULL) FROM DUAL;

-- 조건식에 들어가는 값들..
-- IS NULL
-- IS NOT NULL
--

-- CASE문 /유사 스위치문 --
SELECT 
	CASE BUYER_GENDER
		WHEN '남' THEN '남성고객'
		WHEN '여' THEN '남성고객'
		ELSE '중성'
	END AS "성별"
FROM TBL_BUYER;

-- START WITH문 --
--START WITH ---
--CONNECT BY PRIOR 부모와 자식 관계 정립

-- RANK()
SELECT 
	PRODUCT_NAME AS "상품명",
	PRODUCT_PRICE AS "가격",
	RANK() OVER(ORDER BY PRODUCT_PRICE) AS "RANK()"
FROM TBL_PRODUCT;

-- DENSE_RANK()
SELECT 
	PRODUCT_NAME AS "상품명",
	PRODUCT_PRICE AS "가격",
	DENSE_RANK() OVER(ORDER BY PRODUCT_PRICE) AS "DENSE_RANK()"
FROM TBL_PRODUCT;

SELECT 
	PRODUCT_NAME AS "상품명",
	PRODUCT_PRICE AS "가격",
	DENSE_RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE) AS "파티션",
	SUM(PRODUCT_PRICE) OVER (PARTITION BY PRODUCT_NAME) AS "합계" 
FROM TBL_PRODUCT;

-- ROW_NUMBER()
SELECT 
	PRODUCT_NAME AS "상품명",
	PRODUCT_PRICE AS "가격",
	ROW_NUMBER() OVER(ORDER BY PRODUCT_PRICE DESC) AS "ROW_NUMBER"
FROM TBL_PRODUCT;

-- 분석 함수
SELECT
	PRODUCT_PRICE,
	LEAD(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE) AS "LEAD",
	LAG(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "LAG",
	FIRST_VALUE(PRODUCT_PRICE) OVER(ORDER BY PRODUCT_PRICE) AS "FIRST_VALUE",
	LAST_VALUE(PRODUCT_PRICE) OVER(
		ORDER BY PRODUCT_PRICE
		ROWS BETWEEN 1 PRECEDING AND 5 FOLLOWING
	) AS "LAST_VALUE",
	NTH_VALUE(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	CUME_DIST() OVER(ORDER BY PRODUCT_PRICE) AS "CUME_DIST",
	PERCENT_RANK() OVER(ORDER BY PRODUCT_PRICE) AS "PERCENT_RANK"
FROM TBL_PRODUCT;

-- 집계 쿼리 (누적합 구할 때 많이 사용)
-- ROLLUP : 이름별로 묶어서 연산해줌
SELECT 
	PRODUCT_NAME, 
	PRODUCT_PRICE, 
	SUM(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY ROLLUP(PRODUCT_NAME, PRODUCT_PRICE);

-- CUBE : 가격대가 같은 애들이 묶임
SELECT 
	PRODUCT_NAME, 
	PRODUCT_PRICE, 
	SUM(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY CUBE(PRODUCT_NAME, PRODUCT_PRICE);

-- GROUPING SETS() : 
SELECT 
	PRODUCT_NAME, 
	PRODUCT_PRICE, 
	SUM(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY GROUPING SETS(
	(PRODUCT_NAME, PRODUCT_PRICE),
	PRODUCT_PRICE,
	()	/*총 합*/
);
